####################################################################################################
# @author David Kirwan https://github.com/davidkirwan
# @description Ruby Rake script to handle launching of job workers.
#
# @usage 'rake -T' or 'rake --tasks' to get a list of tasks
#
# @date 2015-03-02
####################################################################################################
### => Import libs
require 'fileutils'
require 'logger'
require 'redis'
require 'rspec'
require 'rspec/core/rake_task'
require File.dirname(__FILE__) + "/lib/common.rb"

# Include lib/common/tasks
include Common::Tasks
RSpec::Core::RakeTask.new(:spec)

# Setup variables
begin
  @log = Logger.new(STDOUT)
  @log.level = Logger::DEBUG
  @date = DateString.now # Common::Tasks::DateString#now

rescue Exception => e
  raise e
end

# Default Task
task :default => 'worker:start'

namespace :worker do

  desc "Start the job worker"
  task :start do
    @log.debug "Task worker:start starting: #{DateString.now}"
    tasktimer = Time.now

    # Configure the queue to subscribe to
    queue = ENV['queue'] ||= 'dxspider'

    redis = Redis.new
    trap(:INT) { puts; exit }

    begin
      redis.subscribe(queue) do |on|
        on.subscribe do |channel, subscriptions|
          puts "Subscribed to ##{channel} (#{subscriptions} subscriptions)"
        end

        on.message do |channel, message|
          puts "##{channel}: #{message}"
          #dxspider: DX de W4IMD:     50145.0  W4ILT        EM84AB<ES>EL09SN               0248Z EM84
          data = parse(message)

          puts data

          redis.unsubscribe if message == "exit"
        end

        on.unsubscribe do |channel, subscriptions|
          puts "Unsubscribed from ##{channel} (#{subscriptions} subscriptions)"
        end
      end
    rescue Redis::BaseConnectionError => error
      puts "#{error}, retrying in 1s"
      sleep 1
      retry
    end

    @log.debug "Task worker:start complete: #{DateString.now} duration: #{Time.now - tasktimer} seconds"
  end
end


def parse(message)
  begin
    data = message.delete("\a").split(/\s+/)
    data.delete_at(0)
    data.delete_at(0)
    puts data.inspect

    dx_freq = data[1]

    if (data[data.size-1] =~ /\d+Z/) == 0
      time = data[data.size-1]
    else
      time = data[data.size-2]
    end
  rescue ArgumentError => e
    return {:freq=>nil, :time=>nil, :error=>e}
  end

  {:freq=>dx_freq, :time=>time}
end
